---
title: Jvm 垃圾回收
order: 3
author: Thechc
category: Java
tag:
  - JVM
star: true
---

>只要比你光头就能比你强:hear_no_evil:

![](http://image.augsix.com/materials/jvm/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-mainImage.jpeg)

## 前言

在平时开发中并不需要我们自己去触发Jvm去进行垃圾回收，Jvm自动会帮我们去回收。那么Jvm又是怎么判断哪些个垃圾要回收呢？又是怎么回收的？

## 如何判断是不是垃圾，在座的各位都是垃圾？

在生活中我们对垃圾的定义是：我们不需要了就是垃圾。比如舔狗。

<img src="http://image.augsix.com/materials/jvm/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-extra1.jpg" style="zoom: 50%;" />

那么Jvm是怎么判断对象是不是垃圾的呢？常见的算法有引用计数算法、可达性分析算法

* 引用计数算法

  ![](http://image.augsix.com/materials/jvm/202112161725660.png)

  引用计数法的原理是当对象被应用的时候就+1，引用失效就-1，当引用数数量为0时说明对象不在被需要，可以当成垃圾进行回收。

  > 引用计数算法虽然原理简单，判定高效，但是主流的虚拟机并没有使用引用计数法来管理内存，因为引用计数法很难解决对象中的相互循环引用的问题。

* 可达性分析算法

  ![](https://raw.githubusercontent.com/Thechc/materials/main/img/202112161806841.png)

  可达性分析算法以一个个**GC Roots**作为根对象的节点集合，从**GC Roots**起根据引用关系相下搜索，被引用的对象节点用**引用链**连接，如果某个对象没用被**GC Roots**连接，那么该对象可以被当场垃圾回收。


  那什么是GC Roots？在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： 

  * 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 

    参数、局部变量、临时变量等。 

  * 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 

  * 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。

  * 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 

  * Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 

    NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。

  * 所有被同步锁（synchronized关键字）持有的对象。

  * 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 

  > Jvm垃圾回收器都是基于可达性分析算法实现的

> Jvm主要的5大区域中程序指示器、虚拟机栈、本地方法栈因为随着线程消亡所以并不需要考虑垃圾回收。方法区因为垃圾回收性价比很低，因此《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集。所以我们提到的垃圾收集一般都是堆的垃圾回收。

##  找到了垃圾后怎么回收呢

前面提到Jvm通过可达性分析算法判断对象是不是垃圾，那么找到之后虚拟机还要对不属于垃圾的对象(也是就被**GC Roots**引用到的对象)进行回收整理。

最早出现垃圾回收算法是**标记-清除**，先标记出需要回收的对象，再清除未标记的垃圾对象。也可以反过来标记垃圾对象，然后清除掉。标记对象的过程其实就是判断对象是否属于垃圾的过程(上面提到的可达性分析算法判断对象是否垃圾)。

![](http://image.augsix.com/materials/jvm/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)

> **标记-清除**算法虽然简单，但是有两个缺点。
>
> * 如果需要回收的垃圾有很多，意味着需要进行大量的标记和删除动作，影响回收效率。
>
> * 回收后回产生大量不连续的内存碎片，造成内存空间碎片化。如果在对较大对象分配内存是找不到连续的内存空间，虚拟机不得不提前触发垃圾收集动作。

针对**标记-清除**算法遗留的问题，在**标记-清除**的基础上进行优化。将可用内存分为同大小的两块区域，每次只用一块，正在使用的一块区域内存不足的时候，将当前内存中存活的对象复制到另外一块上面，再把原来区域内的对象清空。这种算法被称为**标记-复制**。在堆内存的新生代中就是用这种算法思想来回收新生代垃圾对象的。

<img src="http://image.augsix.com/materials/jvm/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" style="zoom:170%;" />

<img src="http://image.augsix.com/materials/jvm/202112201422296.png" style="zoom:150%;" />

> **标记-复制**虽然解决了内存空间碎片化问题，但是也存在两个问题。
>
> * 算法需要复制对象，如果存活的对象很多，复制操作就会是很大的资源消耗。
>
> * 因为划分出了两块区域，存放对象少的区域的内存空间利用率是过剩的。

在堆内存的老年代中的对象存活数量多时间久不容易触发垃圾回收且存在较大的对象，所以**标记-复制**不适合作为老年代的垃圾回收实现。那么既然**标记-复制**的问题是因为划分了两块区域造成的，如果不分区域，只是将存活对象移到一边，可回收对象移到另外一边，也就不会有内存空间利用率过剩问题，而且复制移动的对象也相对减少了。这就是针对老年代的**标记-整理**算法。

<img src="http://image.augsix.com/materials/jvm/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" style="zoom:250%;" />

##  从垃圾回收思考分代收集

为了保证程序有足够的内存运行，垃圾回收是必要的。而且根据前人的经验证实了大多对象的生命周期都很短，难以熬过垃圾回收的过程，只有少数对象能经过多轮垃圾回收还存活下来。生命周期短的对象需要频繁的垃圾回收才能保证有足够的内存空间并提高内存利用率。而长久存活的对象如果频繁垃圾回收，那就需要频繁的标记复制操作，消耗不必要的资源。另外在垃圾回收的时候是会引起**STW(Stop The World)**的,也就是停止对程序的访问，如果在垃圾回收时间内还是有对象在新增的话，那垃圾回收的时候不就乱套了 ，所以需要将生命周期不同的对象分开。

生命周期短的分为新生代，长的分为老年代。在新生代发生的垃圾回收称为Minor GC，在老年代发生的GC称为Full GC(也就是整个对的垃圾回收)。也有称为Major GC的(只有CMS垃圾回收器才有单独对老年代的回收行为)。上面有提到新生代的垃圾回收都是用的是标记-复制算法实现的。我们再来思考一下生命周期短的对象中也有可能有些对象是经过两三次甚至是八九次垃圾回收才变成垃圾的。为了尽可能的提高内存利用率就需要再细化一下新生代的分区。

新生代再分成Eden区和Servivor区，Servivor区又分为Servivor From、Servivor To。在垃圾回收前Servivor To保持清空状态。在新生代进行Minor GC时Eden区把存活下来的对象直接复制到ServivorTo中(对象的年龄会+1)，Servivor From原先时存放经过一次以上垃圾回收还存活的对象，进行Minor GC时没有被GC Roots引用到的就变成垃圾，存活下来的对象年龄再+1。在对象的年龄加到15的时候会被复制到老年代中，年龄未满15的复制到Servivor To。然后Eden和Servivor From就剩下可以删除的垃圾对象了。对垃圾对象清空后，把Servivor From、Servivor To名字交换。确保下次Minor GC时Servivor To还是保持清空状态。

Full GC就是老年代垃圾回收也是整个堆内存的垃圾回收了，在新生代一直往老年代加入对象时，老年代发现内存已经不足以存放新对象时会触发一次Full GC。如果Full GC后还是没有空间存放就会抛出OutOfMemoryError异常。

>分代收集理论：
>1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
>2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
>3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

##  跨代引用

如果在新生代发生Minor GC的时候GC Roots发现引用到了老年代的垃圾回收该怎么办,是不是要继续扫描老年代的对象。那不相当于对整个堆进行了扫描。为了解决这个问题垃圾收集器在新生代中加入了名为记忆集的数据结构。

记忆集是用于记录从非收集区域指向收集区域的指针集合。记录粒度从小到大有字长精度(精确到机器子长，一般为32位或64位)、对象精度(精确到一个对象)、卡精度(精确到一块内存区域)。为了减小记忆集合的存储与维护成本，一般会使用卡精度来实现记忆集，这种方式也被称为卡表，卡表中的每一块内存区域称为卡页。

当卡页存在跨代引用的时候就把当页标记成1(也称脏页)，没有就标记成0。GC Roots扫描时遇到标记为1的卡页就不往下扫描了。

![](http://image.augsix.com/materials/jvm/jvm-%E5%8D%A1%E8%A1%A8%E5%8D%A1%E9%A1%B5.png)
